
# Лабораторная работа № 3 <!-- omit in toc -->
# Контейнеры <!-- omit in toc -->

- [1 Теоретические сведения](#1-теоретические-сведения)
  - [1.1 Обработка ошибок: механизм исключений](#11-обработка-ошибок-механизм-исключений)
  - [1.2 Работа с динамической памятью](#12-работа-с-динамической-памятью)
  - [1.3 Деструктор и идиома RAII](#13-деструктор-и-идиома-raii)
  - [1.4 Правило трёх](#14-правило-трёх)
- [2 Обязательное задание](#2-обязательное-задание)
  - [2.1 Общее задание](#21-общее-задание)
  - [2.2 Варианты](#22-варианты)
  - [2.3 Нормы](#23-нормы)
- [3 Факультативное задание](#3-факультативное-задание)

# 1 Теоретические сведения

## 1.1 Обработка ошибок: механизм исключений

В процессе работы функции (метода) могут возникать непредвиденные (исключительные) ситуации.
Функция должна иметь возможность каким-либо образом о них сообщать.
Одним из способов является возврат кода ошибки, однако такой способ приводит к разбуханию кода.
Альтернативным способом сообщения об ошибке является механизм исключений.

Исключение представляет из себя временный объект одного из специальных типов.
Могут использоваться типы из [&lt;stdexcept&gt;](https://en.cppreference.com/w/cpp/header/stdexcept).
Для первоначального ознакомления мы рекомендуем ограничиться
использованием типов
[`std::runtime_error`](https://en.cppreference.com/w/cpp/error/runtime_error)
и
[`std::logic_error`](https://en.cppreference.com/w/cpp/error/logic_error).

Объект исключения используется для сигнализации об ошибке.
Цель объекта-исключения состоит в том, чтобы передать информацию из точки,
в которой произошла ошибка, в код, который должен ее обработать.
Если код, который должен обработать исключение, *не нашёлся* (исключение не обработано),
то программа прекращает свою работу.

Рассмотрим пример:

```cpp
#include <iostream>

using namespace std;

int div(int a, int b) {
  return a / b;
}

// В данном примере суть вычисляемого выражения не важна.
// Важен факт вызова div.
int compute(int a, int b, int x) {
  int c = div(a, b);
  int r = c + x;
  return r;
}

int main() {
  cout << compute(1, 0, 42);
  return 0;
}
```

В С++ целочисленное деление на 0 приведёт к
[неопределённому поведению](https://ru.wikipedia.org/w/index.php?title=%D0%9D%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5&stable=1).
Чтобы избежать неопределённого поведения, можно сообщить вызывающему коду об ошибке:
создать объект исключения (здесь больше всего подходит тип `std::logic_error`) с описанием ошибки
и **сгенерировать ("бросить", "кинуть") исключение** с помощью оператора `throw`:

```cpp
#include <stdexcept>

using namespace std;

int div(int a, int b) {
  if (b == 0){
    throw logic_error("Division by zero!");
  }
  return a / b;
}
```

Оператор `throw` **прерывает выполнение кода**.
При этом функция, в которой произошло исключение, **значение не возвращает** (ведь её выполнение было прервано).
Более того, **прерывается и вся цепочка вызывающих функций**:
так как вызываемая функция `div` не вернула значение,
то вызывающая функция `compute` продолжать свою работу не может и тоже прерывается.

То есть при возникновении исключения в процессе работы функции `div` в следующем коде
```cpp
int compute(int a, int b, int x) {
  int c = div(a, b);
  int r = c + x;
  return r;
}
```
выполнение `compute` тоже прервётся в месте вызова `div` и исключение *полетит* дальше,
в функцию, которая вызвала `compute` и т. д.

Для того, чтобы остановить прерывание вызывающих функций,
в одной из них должен встретиться обработчик ошибки.
Обычно обработчик пишется в той функции,
на уровне которой известно, как обработать исключительную ситуацию.
Обработчик пишется для конкретного типа исключения.
То есть можно написать свой обработчик на каждый тип исключения.

Обработчик(и) ошибки задаются с помощью синтаксической конструкции `try-catch`:
```
try {
  код_который_потенциально_может_кинуть_исключение;
}
catch (const тип_исключения_1& имя_объекта_исключения_типа_1) { // обработчик_1
  код_обработки_исключения_типа_1;
}
catch (const тип_исключения_2& имя_объекта_исключения_типа_2) { // обработчик_2
  код_обработки_исключения_типа_2;
}
```

В блок `try` помещается код, который потенциально может вызвать исключение.
Очередной обработчик задаётся с помощью ключевого слова `catch`.
После ключевого слова `catch` в круглых скобках указывается тип обрабатываемого данным обработчиком
исключения и имя, с помощью которого можно обратиться к объекту исключения в данном обработчике.
У объектов исключений из `<stdexcept>` есть метод `what`,
который позволяет получить текстовое описание ошибки.

Пример с обработкой исключения на уровне функции `main`:
```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

int div(int a, int b) {
  if (b == 0){
    throw logic_error("Division by zero!");
  }
  return a / b;
}

int compute(int a, int b, int x) {
  int c = div(a, b);
  int r = c + x;
  return r;
}

int main() {
  try {
    cout << compute(1, 0, 42);
    cout << "\nOK\n";
  }
  catch (const logic_error& e) {
    cout << e.what() << '\n';
  }
  return 0;
}
```

Обратим внимание, что та часть кода, которая находится в блоке `try` функции `main` после той строки,
в которой произошло исключение, также выполнена не будет (оператор вывода `OK` не будет вызван).

- **Если исключение не возникает**, то выполняется весь блок кода `try`,
  далее управление передаётся инструкции, следующей сразу после `try-catch`
  (тело ни одного обработчика не будет выполнено).
- **Если возникает исключение и в одной из вызывающей функции существует обработчик**,
  который способен обработать исключение этого типа, то будет выполнено тело этого обработчика.
  При этом весь пользовательский код, находящийся между местом генерации исключения и
  местом объявления обработчика, выполнен не будет.
  После выполнения тела обработчика управление передаётся инструкции,
  следующей сразу после той конструкции `try-catch`, в которой нашёлся обработчик.
- **Если возникает исключение, но не существует обработчика**,
  который способен обработать исключение этого типа,
  (например, `compute` сгенерирует исключение любого другого типа кроме `logic_error`),
  то исключение *пролетит* сквозь весь стек и покинет функцию `main`.
  Все функции в вызывающей цепочке будут прерваны.
  Когда исключение покидает `main`, то обработать его будет уже некому и
  программа аварийно прервёт свою работу.
  При этом не будет выполнен никакой пользовательский код, находяшийся после инструкции `throw`,
  которая сгенерировала исключение.
- Разные типы исключений могут ловиться разными обработчиками,
  находящимися на разных уровнях (функциях) в иерархии цепочки вызовов.
- Обратите внимание, как исключения упрощают вид `compute`.
  - При сообщении об ошибки с помощью кода возврата, в `compute` пришлось бы явно проверять результат вызова `div`.
  - При использовании механизма исключений `compute` выглядит максимально просто.
    В случае генерации исключения в функции `div`, исключение просто пролетит *сквозь* `compute`.
    Никакой обработки ошибок на уровне `compute` не происходит.

Существует специальный обработчик `catch`, который может ловить исключение любого типа:
```cpp
try {
  // ...
}
catch (...) {
  // ...
}
```
Недостаток использования такого обработчика в том, что нельзя получить сам объект исключения.

В C++ особое значение имеют функции (методы), для которых гарантируется,
что никакое исключение их никогда не покинет.
То есть вызов такой функции никогда не приведёт к генерации исключения для вызывающего кода.
- На самом деле, кинуть исключение в такой функции можно.
  Но если оно покинет пределы этой функции,
  это приведёт к немедленному завершению программы.

Для обозначения таких функций в их заголовке может указываться ключевое слово `noexcept`:
```cpp
int sum(int a, int b) noexcept {
  // Здесь исключению возникнуть просто негде
  return a + b;
}
```
Наличие модификатора `noexcept` позволяет компилятору в некоторых случаях генерировать более эффективный код.

Отметим, что все функции из заголовочных файлов стандартной библиотеки Си
никогда не генерируют исключений по очевидной причине - в Си механизма исключений нет.

См. также:
- [Refactoring Guru: Замена кода ошибки исключением](https://refactoring.guru/ru/replace-error-code-with-exception)

Нормы:
- [E.2: Throw an exception to signal that a function can’t perform its assigned task](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e2-throw-an-exception-to-signal-that-a-function-cant-perform-its-assigned-task)
- [E.3: Use exceptions for error handling only](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e3-use-exceptions-for-error-handling-only)
- [E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e12-use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable)
- [E.15: Throw by value, catch exceptions from a hierarchy by reference](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference)
- [E.17: Don’t try to catch every exception in every function](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e17-dont-try-to-catch-every-exception-in-every-function)
- [E.18: Minimize the use of explicit try/catch](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e18-minimize-the-use-of-explicit-trycatch)



## 1.2 Работа с динамической памятью

Выделение/освобождение динамической памяти осуществляется с помощью операторов `new` и `delete`.

- Выделение и освобождение памяти под один элемент - операторы `new` и `delete`:
```cpp
// Примитивный тип без инициализации (нерекомендуемый вариант)
float* fp1 = new float; // ⚠ Выделенная память не инициализируется
*fp1 = 0;

// Примитивный тип с инициализацией (рекомендуемый вариант)
float* fp2 = new float(); // Можно указать своё значение в скобках

// Объект некоторого класса T
T* tp1 = new T;       // Инициализация конструктором по умолчанию
T* tp2 = new T(3, 4); // Можно использовать нужную перегрузку конструктора

// Освобождение памяти
delete tp2;
delete tp1;
delete fp2;
delete fp1;
```

- Выделение и освобождение памяти под массив - операторы `new[]` и `delete[]`:
```cpp
const int n = 10;

// Примитивный тип без инициализации
float* fp1 = new float[n]; // ⚠ Выделенная память не инициализируется
std::fill_n(fp1, n, 1);    // Заполнить все элементы единичками (#include <algorithm>)

// Примитивный тип с инициализацией
// ⚠ Своё значение в скобках указать нельзя: если нужны ненулевые значения - см. предыдущий вариант
float* fp2 = new float[n](); 

// Объект некоторого класса T
// ⚠ Скобки указать можно, но вот в скобках ничего указывать нельзя - всегда используется конструктор по умолчанию
T* tp1 = new T[n];

// Освобождение памяти
delete[] tp1;
delete[] fp2;
delete[] fp1;
```

- В отличие от функций `malloc`/`free`, операторы занимаются не только выделением/освобождением памяти,
  но и инициализацией/деинициализиацией (с помощью конструкторов/деструкторов).

- В C++ для указания нулевого указателя используется ключевое слово `nullptr`.
  Макрос `NULL` лучше не использовать.

  Пример с сюрпризом на компиляторе `cl` (Visual Studio 2022):
  ```cpp
  #include <iostream>

  using namespace std;

  void f(int) {
    cout << "int overload\n";
  }

  void f(void*) {
    cout << "ptr overload\n";
  }

  int main() {
    f(0);       // int overload
    f(NULL);    // Угадайте, что будет здесь?
    f(nullptr); // ptr overload
  }
  ```

- Если оператор `new`/`new[]` не может выделить память, он сгенерирует исключение типа
  [`std::bad_alloc`](https://en.cppreference.com/w/cpp/memory/new/bad_alloc).
  - Можно подавить генерацию исключения с помощью [std::nothrow](https://en.cppreference.com/w/cpp/memory/new/nothrow).
    В этом случае оператор в случае неудачи вернёт `nullptr`.
- Любая выделенная с помощью `new` память должна быть освобождена.
  Бремя освобождения лежит на программисте.
- В общем случае использование операторов `new`/`delete` не рекомендуется,
  так как накладывает обязательство по ручному освобождению памяти.
  Вместо этого используется [`std::vector`](https://en.cppreference.com/w/cpp/container/vector).
  Однако в текущей лабораторной работе вы пишете свой грубый аналог `std::vector` и поэтому в данной
  (и только в данной!) работе вместо `std::vector` используется ручное управление памятью.

Нормы:
- [E.13: Never throw while being the direct owner of an object](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e13-never-throw-while-being-the-direct-owner-of-an-object)



## 1.3 Деструктор и идиома RAII

Деструктор - специальный метод, который **автоматически** вызывается перед удалением объекта.

Деструктор всегда вызывается автоматически:
- для объектов, расположенных на стеке - в момент выхода объекта из области видимости;
- для объектов, расположенных в куче - в момент вызова оператора `delete`/`delete[]`.

Деструктор в классе `T` описывается как метод:
- без возвращаемого значения (не указывается даже `void`);
- с названием `~T`;
- без параметров.

Демонстрация автоматического вызова деструктора:
```cpp
#include <iostream>

using namespace std;

struct SomeType {
  ~SomeType() {
    cout << "~SomeType\n";
  }
};

int main() {
  {
    cout << "#1\n";
    SomeType obj;
  }

  {
    cout << "#2\n";  
    SomeType* ptr = new SomeType;
    delete ptr;
  }
  
  {
    cout << "#3\n";  
    SomeType* ptr = new SomeType[5];
    delete[] ptr;
  }

  return 0;
}
```

Вышеприведённый код выведет следующее:
```
#1
~SomeType
#2
~SomeType
#3
~SomeType
~SomeType
~SomeType
~SomeType
~SomeType
```

Если в классе не объявлен деструктор, то компилятор генерирует неявную версию деструктора, которая ничего не делает.

После отработки тела деструктора (неважно, явного или неявного) вызываются деструкторы для всех полей-объектов.

Демонстрация автоматического вызова деструктора для полей-объектов:
```cpp
#include <iostream>

using namespace std;

struct Point {
  ~Point() {
    cout << "~Point\n";
  }
};

struct Circle {
  Point center;

  ~Circle() {
    cout << "~Circle\n";
  }
};

int main() {
  {
    cout << "#1\n";
    Circle c;
  }

  {
    cout << "#2\n";  
    Circle* ptr = new Circle();
    delete ptr;
  }
  
  {
    cout << "#3\n";  
    Circle* ptr = new Circle[2]();
    delete[] ptr;
  }

  return 0;
}
```

Вышеприведённый код выведет следующее:
```
#1
~Circle
~Point
#2
~Circle
~Point
#3
~Circle
~Point
~Circle
~Point
```

Отметим некоторые важные моменты касаемо деструкторов:
- Явный деструктор в классе должен предоставляться только в том случае,
  если объекты этого класса владеют какими-либо ресурсами, которые должны быть освобождены.
- В общем случае необходимости предоставлять собственный деструктор нет.
  Если внутри объекта есть необходимость работы с каким-то ресурсом,
  используется специально предназначенный для этого класс.
  - Например, если необходима работа с динамической памятью, используется `std::vector`.
- ⚠ Деструктор всегда вызывается автоматически. Он никогда не должен вызываться явно.
- ⚠ Исключения ни при каких условиях не должны покидать деструктор.
  **Любой деструктор неявно является `noexcept`.**
  **То есть если исключение покинет деструктор, это приведёт к немедленному завершению программы.**

С помощью деструкторов можно реализовать идиому RAII
(Resource Acquisition Is Initialization - получение ресурса есть инициализация).
Смысл этой идиомы заключается в следующем:
- В конструкторе объект получает доступ к какому-либо ресурсу
  (например, выделяется динамическая память, открывается файл или устанавливается соединение по сети)
  и сохраняет описатель ресурса в закрытый член класса.
- В деструкторе ресурс освобождается
  (например, освобождается динамическая память, закрывается файл или закрывается соединение по сети).
- **Вся соль в том, что в C++ деструктор вызывается автоматически.
  Это означает, что с программиста снимается бремя по ручному освобождению ресурса.**


Приведем пример, где ресурсом является динамическая память, тогда описателем ресурса является указатель.
Отметим, что приводимый ниже класс - это лишь иллюстрация идиомы RAII.
В реальности писать такой класс для динамической памяти не надо (ведь есть `std::vector`).
Однако эта идиома может применяться не только к динамической памяти,
но и к любому ресурсу, который требует своего освобождения.

```cpp
class IntArray {
private:
  int* _ptr;
  size_t _size;
  
public:
  IntArray(size_t size) : _size(size) {
    _ptr = new int[size]();
  }

  IntArray(const IntArray&) = delete;

  IntArray& operator=(const IntArray&) = delete;

  size_t size() const {
    return _size;
  }

  const int* ptr() const {
    return _ptr;
  }

  int* ptr() {
    return _ptr;
  }

  ~IntArray() {
    delete[] _ptr;
  }
};

int main() {
  IntArray data(5);
  
  // Работа с объектом: data.ptr() / data.size()
  
  // Вручную освобождать ничего не нужно!
  // При завершении функции автоматически вызовется деструктор IntArray,
  // который освободит выделенную в конструкторе динамическую память.

  return 0;
}
```

Обратите внимание на явный запрет операций копирования (конструктора копирования и оператора присваивания).
Если их не запретить, компилятор сгенерирует неявные определения.
Напомним, что неявные реализации операций копирования сводятся к простому копированию всех полей.
- Подумайте, чем чревато наличие таких неявных определений?

См. также:
- [C++ Idioms: Resource Acquisition Is Initialization](https://en.wikibooks.org/w/index.php?title=More_C%2B%2B_Idioms/Resource_Acquisition_Is_Initialization&stable=1)

Нормы:
- [E.16: Destructors, deallocation, swap, and exception type copy/move construction must never fail](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e16-destructors-deallocation-swap-and-exception-type-copymove-construction-must-never-fail)



## 1.4 Правило трёх

Рассмотрим три специальных члена класса, для которых компилятор всегда предоставляет неявную реализацию,
если только не предоставлена явная реализация:
- конструктор копирования (неявная реализация просто копирует все поля);
- оператор присваивания (неявная реализация просто копирует все поля);
- деструктор (неявная реализация ничего не делает).

Конструктор копирования и оператор присваивания также называют операциями копирования,
так как они оба позволяют создать копию объекта:
- конструктор - путём инициализации нового объекта;
- оператор - путём изменения уже существующего объекта.

Возьмем пример из прошлого пункта и уберём из него явный запрет на операции копирования:

```cpp
// ⚠ Это очень плохой код

class IntArray {
private:
  int* _ptr;
  size_t _size;
  
public:
  IntArray(size_t size) : _size(size) {
    _ptr = new int[size]();
  }

  size_t size() const {
    return _size;
  }

  const int* ptr() const {
    return _ptr;
  }

  int* ptr() {
    return _ptr;
  }

  ~IntArray() {
    delete[] _ptr;
  }
};
```

Так как явные реализации операций копирования не предоставлены, это приведёт к генерации неявных реализаций.
Неявные реализации выполняют почленное копирование.
Таким образом, вышеприведённый пример без явно определённых/запрещённых операций копирования
эквивалентен классу, в котором бы эти операции были явно заданы следующим образом:
```cpp
class IntArray {
public:
  IntArray(const IntArray& other) : _ptr(other._ptr), _size(other._size) {
  }

  IntArray& operator=(const IntArray& other) {
    _ptr = other._ptr;
    _size = other._size;
  }

  // ...
};
```

Обратим внимание, что такие реализации создают **поверхностную** копию.

Рассмотрим следующий код:
```cpp
IntArray a(5);
{
  IntArray b(a); // b._ptr = a._ptr
} // Вызывается деструктор b
// ⚠ a._ptr - висячий указатель
```

Для инициализации объекта `a` используется конструктор с параметром, который выделяет новую память.

Для инициализации объекта `b` используется неявный конструктор копирования,
который копирует указатель из объекта `a`, но сам никакой новой памяти не выделяет.

**Таким образом у нас оказывается два разных объекта, у которых поле `_ptr` указывает на одну и ту же область памяти.
Если один из объектов будет уничтожен (например, `b`), то его деструктор освободит память, на которую указывает `_ptr`.
В итоге в ещё живом объекте `a` указатель `_ptr` начинает указывать на уже недоступную память.
Возникает [висячий указатель](https://ru.wikipedia.org/w/index.php?title=%D0%92%D0%B8%D1%81%D1%8F%D1%87%D0%B8%D0%B9_%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C&stable=1),
который является грубейшей и опаснейшей ошибкой.**

**Аналогичным образом можно показать, что использование неявной реализации оператора присваивания
приведет не только к висячему указателю, но и к [утечке памяти](https://ru.wikipedia.org/w/index.php?title=%D0%A3%D1%82%D0%B5%D1%87%D0%BA%D0%B0_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8&stable=1).**

Таким образом, когда в классе есть потребность в явном деструкторе (который освобождает какой-то ресурс),
то возникает потребность и в явных операциях копирования, которые способны правильно скопировать ресурс
(простое копирование, как в случае указателя, может быть недопустимым).

Отсюда возникает так называемое **правило трёх**: если в классе явно определяется один из следующих трёх методов
(конструктор копирования, оператор присваивания или деструктор), то все три метода должны быть определены явно.

В общем случае используется один из двух вариантов:
- явный запрет операций копирования с помощью `= delete`;
- реализация глубокого копирования.

Рассмотрим, как могли бы выглядеть операции глубокого копирования для примера выше.

Конструктор копирования (осуществляет глубокое копирование):
```cpp
class IntArray {
public:
  IntArray(const IntArray& other) : _ptr(new int[other._size]), _size(other._size) {
    for (size_t i = 0; i < _size; ++i) {
      _ptr[i] = other._ptr[i];
    }
  }

  // ...
};
```

Оператор присваивания (сводится к конструктору копирования по идиоме [copy-and-swap](https://en.wikibooks.org/w/index.php?title=More_C%2B%2B_Idioms/Copy-and-swap&stable=1)):
```cpp
public:
  void swap(IntArray& other) noexcept {
    std::swap(_ptr, other._ptr);
    std::swap(_size, other._size);
  }

  IntArray& operator=(IntArray other) {
    swap(other);
    return *this;
  }

  // ...
};
```

См. также:
- [Правило трёх](https://ru.wikipedia.org/w/index.php?title=%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D1%82%D1%80%D1%91%D1%85_(C%2B%2B)&stable=1)
- [C++ Idioms: Copy-and-swap](https://en.wikibooks.org/w/index.php?title=More_C%2B%2B_Idioms/Copy-and-swap&stable=1).

Нормы:
- [E.16: Destructors, deallocation, swap, and exception type copy/move construction must never fail](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e16-destructors-deallocation-swap-and-exception-type-copymove-construction-must-never-fail)



# 2 Обязательное задание

## 2.1 Общее задание

**⚠ Примечание.**
В данной лабораторной работе вас просят написать **свой класс-контейнер**,
в котором вы **сами управляете динамической памятью**.
Это сделано исключительно с учебной целью - чтобы лучше понять как устроено управление памятью в C++.
- **В данной лабораторной работе** запрещено использовать любые контейнеры
  или умные указатели из стандартной библиотеки.
  Управлять памятью вы должны самостоятельно (использовать операторы `new` и `delete`).
  Хоть это и не соответствует реальной практике (*изобретаем велосипед*), но позволяет лучше разобраться в теме.
- **Во всех последующих лабораторных работах**, наоборот, в соответствии с реальной практикой,
  любое ручное управление памятью становится табу.
  Для управления памятью должны использоваться специально предназначенные для этого
  классы стандартной библиотеки - контейнеры и умные указатели (*не изобретать велосипед*).

Номер вашего варианта совпадает с номером варианта в предыдущей лабораторной работе.

1. Реализовать класс-контейнер для хранения объектов типа `T`,
   где `T` - ваш класс из прошлой лабораторной работы.

   В классе-контейнере внутри для хранения объектов типа `T` должен использоваться динамический массив.
   Если ваш тип `T` не содержит конструктор по умолчанию - добавьте его.

   В классе-контейнере предоставить:
   - конструктор по умолчанию, создающий пустой контейнер;
   - метод получения количества элементов в контейнере;
   - метод получения элемента из контейнера по указанному индексу;
     - на ваше усмотрение вместо этого метода может быть предоставлена перегрузка оператора `[]`.
   - метод вставки элемента в контейнер по указанному индексу;
   - метод удаления элемента из контейнера по указанному индексу;
   - другие необходимые члены для обеспечения **глубокой копируемости** и корректного управления памятью (правило трёх).

   При указании некорректного индекса должно генерироваться исключение.

1. Написать функцию согласно варианту, которая:
   - принимает контейнер (и, может быть, некоторые другие параметры в зависимости от варианта);
   - возвращает **индекс элемента**, удовлетворяющего некоторому критерию (см. вариант):
     - если такого элемента нет или контейнер пустой - вернуть -1;
     - если есть несколько элементов, удовлетворяющих критерию - вернуть индекс самого первого из них.

1. Продемонстрировать работоспособность написанного класса, в том числе его копируемость,
   одним из следующих способов:
   - классически с использованием `main` и ввода данных пользователем с консоли;
   - с использованием модульного тестирования (см. факультативную часть предыдущей лабораторной работы).
   
   В плане оценки оба способа эквиваленты (за модульное тестирование какие-либо дополнительные баллы не ставятся).

   При использовании модульного тестирования:
   - не нужно писать свой `main` и объявлять отдельное исполняемое приложение:
     - в лучшем случае у вас будет две цели сборки: библиотека с классами и исполняемое приложение с тестами;
     - в худшем случае можно обойтись одной целью сборки: исполняемым приложением с тестами.
   - тестами должны быть покрыты:
     - метод вставки;
     - метод удаления;
     - оператор присваивания;
     - функция согласно варианту.
   - тесты должны проверять в том числе и генерацию исключения при указании некорректного индекса
     (см. [GoogleTest: Exception Assertions](https://google.github.io/googletest/reference/assertions.html#exceptions)).



## 2.2 Варианты

- Слово *заданный* означает необходимость в дополнительном параметре функции.
- Если идут приближённые вычисления, то $\epsilon$ - это тоже дополнительный параметр функции.

1. Дробь, значение которой равно *заданному* вещественному числу (приближённо с некоторой погрешностью $\epsilon$).
1. Интервал, который содержит в себе значение 0.
1. Матрица, которая является единичной (приближённо с некоторой погрешностью $\epsilon$).
1. Вектор, который перпендикулярен *заданному* вектору (приближённо с некоторой погрешностью $\epsilon$).
1. Вектор, который коллинеарен *заданному* вектору (приближённо с некоторой погрешностью $\epsilon$).
1. Прямоугольник, который содержит *заданную* точку (точка находится внутри прямоугольника).
1. Окружность, которая содержит *заданную* точку (точка находится внутри окружности).
1. Треугольник с периметром, равным заданному вещественному числу
   (приближённо с некоторой погрешностью $\epsilon$).
1. Квадратичная функция, значение которой в точке $x=0$ превосходит *заданное* значение.
1. Цилиндр, который содержит *заданную* точку (точка находится внутри цилиндра).
1. Отрезок, который содержит *заданную* точку (приближённо с некоторой погрешностью $\epsilon$).
1. Прямая, которая содержит *заданную* точку (приближённо с некоторой погрешностью $\epsilon$).
1. Денежная сумма, которая превышает *заданную* денежную сумму.
1. Длительность по времени, которая превышает *заданную* длительность по времени.
1. Угол, который превышает *заданный* угол.



## 2.3 Нормы

- [E.2: Throw an exception to signal that a function can’t perform its assigned task](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e2-throw-an-exception-to-signal-that-a-function-cant-perform-its-assigned-task)
- [E.3: Use exceptions for error handling only](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e3-use-exceptions-for-error-handling-only)
- [E.12: Use noexcept when exiting a function because of a throw is impossible or unacceptable](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e12-use-noexcept-when-exiting-a-function-because-of-a-throw-is-impossible-or-unacceptable)
- [E.13: Never throw while being the direct owner of an object](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e13-never-throw-while-being-the-direct-owner-of-an-object)
- [E.15: Throw by value, catch exceptions from a hierarchy by reference](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference)
- [E.16: Destructors, deallocation, swap, and exception type copy/move construction must never fail](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e16-destructors-deallocation-swap-and-exception-type-copymove-construction-must-never-fail)
- [E.17: Don’t try to catch every exception in every function](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e17-dont-try-to-catch-every-exception-in-every-function)
- [E.18: Minimize the use of explicit try/catch](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e18-minimize-the-use-of-explicit-trycatch)



# 3 Факультативное задание

1. Продемонстрировать работоспособность вашего проекта под операционной системой семейства Linux.
1. Оптимизируйте класс контейнера так, чтобы он не занимался перераспределением
   (выделением/освобождением) памяти при каждой операции вставки/удаления.
   Помимо размера `size` (количество фактических элементов в массиве),
   понадобится также хранить ёмкость `capacity` (количество возможных элементов в массиве).
   - Измените реализацию метода вставки.
     - Если при вставке `size` меньше `capacity`, то память не перераспределяется.
     - Если `size` равен `capacity`, то при перераспределении памяти она выделяется сразу с запасом
       (например, `capacity` удваивается).
   - Измените реализацию метода удаления.
     - При удалении происходит только сдвиг элементов, память никогда не перераспределяется.
   - Предоставьте дополнительный метод `shrink_to_fit` для принудительного перераспределения памяти
     (уменьшения размера буфера `capacity` до фактического размера массива `size`).
   - См. также:
     - [Wikipedia. Dynamic array. Geometric expansion and amortized cost](https://en.wikipedia.org/wiki/Dynamic_array#Geometric_expansion_and_amortized_cost)
     - [Difference between size and capacity of a vector in C++ STL](https://www.geeksforgeeks.org/difference-between-size-and-capacity-of-a-vector-in-cpp-stl/)
     - `std::vector`:
       - [size](https://en.cppreference.com/w/cpp/container/vector/size);
       - [capacity](https://en.cppreference.com/w/cpp/container/vector/capacity);
       - [shrink_to_fit](https://en.cppreference.com/w/cpp/container/vector/shrink_to_fit).
1. Задокументируйте класс, все открытые члены класса, все глобальные функции
   (всё это делается в заголовочном файле) и
   сгенерируйте веб-документацию в формате HTML.
   - Документация пишется в самом коде в виде специальных комментариев.
     Для методов (функций) задокументирован должен быть не только сам метод (функция),
     но и возвращаемое значение и все параметры.
     См. [Doxygen: Documenting the code](https://www.doxygen.nl/manual/docblocks.html).
   - Для генерации веб-документации:
     - Установите Doxygen.
        - Linux (`apt`): `sudo apt install doxygen`.
        - MacOS/Windows: используйте установщик с [официального сайта](https://www.doxygen.nl/download.html).
     - Сгенерируйте HTML-документацию. См. [Doxygen: Getting started](https://www.doxygen.nl/manual/starting.html).
     - Результатом работы генератора должна быть директория (`html`), в которой находится HTML-документация.
        В этой директории должен находиться файл `index.html`, который можно открыть в браузере.
        Сгенерированная документация должна выглядеть (по крайней мере, шапка) примерно вот так:
        [OpenCV Documentation](https://docs.opencv.org/4.x/index.html).
   - Для зачёта факультативного пункта откройте преподавателю сгенерированную HTML-документацию в браузере.
     - При необходимости (по требованию преподавателя) покажите
       каким образом документируется код и/или генерируется HTML-документация.
